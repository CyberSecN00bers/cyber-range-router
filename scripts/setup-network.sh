#!/bin/sh
set -eu

# =========================
# CyberRange Router - setup-network.sh (Alpine)
# =========================

# ---- Core interfaces ----
WAN_IF="eth0"
LAN_TRUNK="eth1"
LAN_MATCH="${LAN_TRUNK}+"

# ---- Preconfigured VLANs ----
MGMT_VID="10"
MGMT_IF="${LAN_TRUNK}.${MGMT_VID}"
MGMT_ADDR="172.16.255.1/24"

DMZ_VID="99"
DMZ_IF="${LAN_TRUNK}.${DMZ_VID}"
DMZ_ADDR="172.16.99.1/24"

# ---- DMZ services ----
GUAC_IP="172.16.99.10"
WAZUH_IP="172.16.99.11"
WAZUH_WAN_PORT="9443"   # WAN:9443 -> Wazuh:443

# ---- Firewall chains ----
VLAN_CHAIN="QM_VLAN"
SERVICES_CHAIN="QM_SERVICES"

# Hairpin UI gating: only allow internal -> WAN_IP:9443 (marked) to reach Wazuh:443
WAZUH_UI_MARK="0x9443"

# Optional hardening
DISABLE_IPV6="${DISABLE_IPV6:-1}"
LOG_FORWARD_DROPS="${LOG_FORWARD_DROPS:-0}"

# Marker block in /etc/network/interfaces for explicit sources
QM_BEGIN="### BEGIN QM-VLAN-SOURCES"
QM_END="### END QM-VLAN-SOURCES"

say() { printf '%s\n' "$*"; }

need_root() {
  if [ "$(id -u)" -ne 0 ]; then
    echo "ERROR: run as root" >&2
    exit 1
  fi
}

cmd_exists() { command -v "$1" >/dev/null 2>&1; }

set_sysctl_kv() {
  key="$1"
  val="$2"
  conf="/etc/sysctl.conf"
  mkdir -p "$(dirname "$conf")"
  if [ -f "$conf" ] && grep -q "^${key}=" "$conf"; then
    sed -i "s|^${key}=.*|${key}=${val}|g" "$conf"
  else
    echo "${key}=${val}" >> "$conf"
  fi
  sysctl -w "${key}=${val}" >/dev/null 2>&1 || true
}

iptables_add_once() {
  tbl="$1"; shift
  ch="$1"; shift
  if [ "$tbl" = "filter" ]; then
    if ! iptables -C "$ch" "$@" 2>/dev/null; then
      iptables -A "$ch" "$@"
    fi
  else
    if ! iptables -t "$tbl" -C "$ch" "$@" 2>/dev/null; then
      iptables -t "$tbl" -A "$ch" "$@"
    fi
  fi
}

ensure_chain() {
  tbl="$1"; ch="$2"
  if [ "$tbl" = "filter" ]; then
    iptables -N "$ch" 2>/dev/null || true
  else
    iptables -t "$tbl" -N "$ch" 2>/dev/null || true
  fi
}

flush_chain() {
  tbl="$1"; ch="$2"
  if [ "$tbl" = "filter" ]; then
    iptables -F "$ch" 2>/dev/null || true
  else
    iptables -t "$tbl" -F "$ch" 2>/dev/null || true
  fi
}

hook_chain_first() {
  tbl="$1"; parent="$2"; child="$3"
  if ! iptables -t "$tbl" -C "$parent" -j "$child" 2>/dev/null; then
    iptables -t "$tbl" -I "$parent" 1 -j "$child"
  fi
}

detect_wan_ip_only() {
  ip -4 addr show dev "$WAN_IF" 2>/dev/null \
    | awk '/inet /{print $2}' \
    | cut -d/ -f1 \
    | head -n1 || true
}

svc_restart() {
  svc="$1"
  rc-service "$svc" restart >/dev/null 2>&1 || {
    rc-service "$svc" stop >/dev/null 2>&1 || true
    rc-service "$svc" start >/dev/null 2>&1 || true
  }
}

# --- IMPORTANT: explicit source lines generation (no wildcard) ---
refresh_qm_sources() {
  interfaces="/etc/network/interfaces"
  [ -f "$interfaces" ] || { echo "ERROR: missing $interfaces"; exit 1; }

  # Ensure marker block exists
  if ! grep -qF "$QM_BEGIN" "$interfaces"; then
    printf '\n# Auto-managed sources for qm-vlan (explicit, no wildcard)\n%s\n%s\n' "$QM_BEGIN" "$QM_END" >> "$interfaces"
  fi

  src_tmp="$(mktemp)"
  # Only include vlan*.conf generated by qm-vlan
  for f in /etc/network/interfaces.d/vlan*.conf; do
    [ -f "$f" ] || continue
    echo "source $f" >> "$src_tmp"
  done

  out_tmp="$(mktemp)"
  awk -v begin="$QM_BEGIN" -v end="$QM_END" -v sf="$src_tmp" '
    BEGIN { inblock=0 }
    $0==begin {
      print
      while ((getline line < sf) > 0) { print line }
      close(sf)
      inblock=1
      next
    }
    $0==end { inblock=0; print; next }

    # Outside block: drop any old source/include to vlan*.conf (avoid duplicates / parse issues)
    inblock==0 {
      if ($1=="include") next
      if ($1=="source" && $2 ~ /^\/etc\/network\/interfaces\.d\/vlan[0-9]+\.conf$/) next
      print
    }
  ' "$interfaces" > "$out_tmp"

  cat "$out_tmp" > "$interfaces"
  rm -f "$out_tmp" "$src_tmp"
}

need_root

say "[+] Packages: iptables, dnsmasq, dos2unix; FIX ifupdown-ng (remove vlan)..."
apk add --no-cache iptables dnsmasq dos2unix >/dev/null
apk del vlan >/dev/null 2>&1 || true
apk add --no-cache ifupdown-ng >/dev/null

rc-update add networking default >/dev/null 2>&1 || true
rc-update add iptables default >/dev/null 2>&1 || true
rc-update add dnsmasq default >/dev/null 2>&1 || true

# Normalize scripts (avoid CRLF)
dos2unix /usr/local/bin/setup-network.sh /usr/local/bin/qm-vlan 2>/dev/null || true

say "[+] Sysctl: enable ip_forward..."
set_sysctl_kv net.ipv4.ip_forward 1

if [ "$DISABLE_IPV6" = "1" ]; then
  say "[+] Sysctl: disable IPv6..."
  set_sysctl_kv net.ipv6.conf.all.disable_ipv6 1
  set_sysctl_kv net.ipv6.conf.default.disable_ipv6 1
fi

# ---- Build WAN config (auto -> static if possible else dhcp) ----
CUR_WAN_ADDR="$(ip -4 addr show dev "$WAN_IF" 2>/dev/null | awk '/inet /{print $2; exit}' || true)"
CUR_WAN_GW="$(ip route show default 2>/dev/null | awk '/default/{print $3; exit}' || true)"

WAN_MODE="${WAN_MODE:-auto}"
WAN_ADDR="${WAN_ADDR:-$CUR_WAN_ADDR}"
WAN_GW="${WAN_GW:-$CUR_WAN_GW}"

if [ "$WAN_MODE" = "auto" ]; then
  if [ -n "$WAN_ADDR" ] && [ -n "$WAN_GW" ]; then
    WAN_MODE="static"
  else
    WAN_MODE="dhcp"
  fi
fi

if [ "$WAN_MODE" = "static" ] && [ -z "$WAN_ADDR" ]; then
  WAN_MODE="dhcp"
fi

say "[+] Write /etc/network/interfaces ..."
mkdir -p /etc/network/interfaces.d
[ -f /etc/network/interfaces ] && cp /etc/network/interfaces "/etc/network/interfaces.bak.$(date +%s)" 2>/dev/null || true

{
  echo "auto lo"
  echo "iface lo inet loopback"
  echo ""
  echo "# WAN"
  echo "auto ${WAN_IF}"
  if [ "$WAN_MODE" = "static" ]; then
    echo "iface ${WAN_IF} inet static"
    echo "    address ${WAN_ADDR}"
    [ -n "$WAN_GW" ] && echo "    gateway ${WAN_GW}"
  else
    echo "iface ${WAN_IF} inet dhcp"
  fi
  echo ""
  echo "# Trunk"
  echo "auto ${LAN_TRUNK}"
  echo "iface ${LAN_TRUNK} inet manual"
  echo "    up ip link set dev ${LAN_TRUNK} up"
  echo "    down ip link set dev ${LAN_TRUNK} down"
  echo ""
  echo "# VLAN10 (mgmt/test)"
  echo "auto ${MGMT_IF}"
  echo "iface ${MGMT_IF} inet static"
  echo "    address ${MGMT_ADDR}"
  echo "    vlan-raw-device ${LAN_TRUNK}"
  echo ""
  echo "# VLAN99 (DMZ)"
  echo "auto ${DMZ_IF}"
  echo "iface ${DMZ_IF} inet static"
  echo "    address ${DMZ_ADDR}"
  echo "    vlan-raw-device ${LAN_TRUNK}"
  echo ""
  echo "# Explicit sources for qm-vlan generated VLANs (no wildcard)"
  echo "${QM_BEGIN}"
  echo "${QM_END}"
} > /etc/network/interfaces

# Fill marker block with explicit source lines
refresh_qm_sources

# Bring up trunk + base VLANs (do NOT bounce WAN)
rc-service networking start >/dev/null 2>&1 || true
ifup "${LAN_TRUNK}" >/dev/null 2>&1 || true
ifup "${MGMT_IF}" >/dev/null 2>&1 || true
ifup "${DMZ_IF}" >/dev/null 2>&1 || true

# Bring up existing user VLANs (if any already exist)
for f in /etc/network/interfaces.d/vlan*.conf; do
  [ -f "$f" ] || continue
  vid="$(basename "$f" | sed -e 's/^vlan//' -e 's/\.conf$//')"
  [ -n "$vid" ] || continue
  ifup "${LAN_TRUNK}.${vid}" >/dev/null 2>&1 || true
done

# ---- dnsmasq ----
say "[+] Configure dnsmasq..."
mkdir -p /etc/dnsmasq.d
[ -f /etc/dnsmasq.conf ] && mv /etc/dnsmasq.conf "/etc/dnsmasq.conf.bak.$(date +%s)" 2>/dev/null || true

cat > /etc/dnsmasq.conf <<EOF
domain-needed
bogus-priv
dhcp-authoritative
no-resolv
server=8.8.8.8
server=1.1.1.1
bind-interfaces
conf-dir=/etc/dnsmasq.d,*.conf
EOF

cat > /etc/dnsmasq.d/vlan10.conf <<EOF
interface=${MGMT_IF}
dhcp-range=172.16.255.100,172.16.255.200,255.255.255.0,24h
dhcp-option=tag:${MGMT_IF},option:router,172.16.255.1
dhcp-option=tag:${MGMT_IF},option:dns-server,8.8.8.8
EOF

cat > /etc/dnsmasq.d/vlan99.conf <<EOF
interface=${DMZ_IF}
dhcp-range=172.16.99.100,172.16.99.200,255.255.255.0,24h
dhcp-option=tag:${DMZ_IF},option:router,172.16.99.1
dhcp-option=tag:${DMZ_IF},option:dns-server,8.8.8.8
EOF

svc_restart dnsmasq

# ---- Firewall / NAT ----
WAN_IP="$(detect_wan_ip_only)"
[ -n "$WAN_IP" ] && say "[+] WAN IP detected: $WAN_IP" || say "[!] WARN: WAN IP not detected yet (hairpin UI needs WAN IP)."

NAT_PRE="QM_NAT_PREROUTING"
NAT_OUT="QM_NAT_OUTPUT"
NAT_POST="QM_NAT_POSTROUTING"
MANGLE_PRE="QM_MANGLE_PREROUTING"

say "[+] iptables: NAT chains..."
ensure_chain nat "$NAT_PRE"
ensure_chain nat "$NAT_OUT"
ensure_chain nat "$NAT_POST"
flush_chain nat "$NAT_PRE"
flush_chain nat "$NAT_OUT"
flush_chain nat "$NAT_POST"
hook_chain_first nat PREROUTING "$NAT_PRE"
hook_chain_first nat OUTPUT "$NAT_OUT"
hook_chain_first nat POSTROUTING "$NAT_POST"

# NAT overload (internet)
iptables_add_once nat "$NAT_POST" -o "$WAN_IF" -j MASQUERADE

# DNAT from WAN -> DMZ
iptables_add_once nat "$NAT_PRE" -i "$WAN_IF" -p tcp --dport 80  -j DNAT --to-destination "${GUAC_IP}:80"
iptables_add_once nat "$NAT_PRE" -i "$WAN_IF" -p tcp --dport 443 -j DNAT --to-destination "${GUAC_IP}:443"
iptables_add_once nat "$NAT_PRE" -i "$WAN_IF" -p tcp --dport "$WAZUH_WAN_PORT" -j DNAT --to-destination "${WAZUH_IP}:443"

# Hairpin DNAT (internal -> WAN_IP:9443 -> Wazuh:443)
if [ -n "$WAN_IP" ]; then
  iptables_add_once nat "$NAT_PRE" -i "$LAN_MATCH" -d "$WAN_IP" -p tcp --dport "$WAZUH_WAN_PORT" -j DNAT --to-destination "${WAZUH_IP}:443"
  iptables_add_once nat "$NAT_OUT" -d "$WAN_IP" -p tcp --dport "$WAZUH_WAN_PORT" -j DNAT --to-destination "${WAZUH_IP}:443"
fi

say "[+] iptables: mangle mark for hairpin UI gating..."
ensure_chain mangle "$MANGLE_PRE"
flush_chain mangle "$MANGLE_PRE"
hook_chain_first mangle PREROUTING "$MANGLE_PRE"

if [ -n "$WAN_IP" ]; then
  iptables_add_once mangle "$MANGLE_PRE" -i "$LAN_MATCH" -d "$WAN_IP" -p tcp --dport "$WAZUH_WAN_PORT" \
    -m conntrack --ctstate NEW -j CONNMARK --set-mark "$WAZUH_UI_MARK"
fi

say "[+] iptables: FORWARD default DROP + chains..."
iptables -F FORWARD
iptables -P FORWARD DROP

ensure_chain filter "$SERVICES_CHAIN"
flush_chain filter "$SERVICES_CHAIN"

ensure_chain filter "$VLAN_CHAIN"
# IMPORTANT: do NOT flush $VLAN_CHAIN (qm-vlan adds per VLAN rules)

iptables_add_once filter FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables_add_once filter FORWARD -j "$SERVICES_CHAIN"
iptables_add_once filter FORWARD -j "$VLAN_CHAIN"

# WAN -> DMZ (published services)
iptables_add_once filter "$SERVICES_CHAIN" -i "$WAN_IF" -o "$DMZ_IF" -p tcp -d "$GUAC_IP" -m multiport --dports 80,443 \
  -m conntrack --ctstate NEW -j ACCEPT

iptables_add_once filter "$SERVICES_CHAIN" -i "$WAN_IF" -o "$DMZ_IF" -p tcp -d "$WAZUH_IP" --dport 443 \
  -m conntrack --ctstate NEW -j ACCEPT

# DMZ -> WAN (updates)
iptables_add_once filter "$SERVICES_CHAIN" -i "$DMZ_IF" -o "$WAN_IF" -m conntrack --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT

# Baseline mgmt VLAN10 (internet + agent + UI via WAN IP only)
iptables_add_once filter "$VLAN_CHAIN" -i "$MGMT_IF" -o "$WAN_IF" \
  -m conntrack --ctstate NEW,ESTABLISHED,RELATED -m comment --comment "mgmt10-inet" -j ACCEPT

iptables_add_once filter "$VLAN_CHAIN" -i "$MGMT_IF" -o "$DMZ_IF" -d "$WAZUH_IP" -p tcp -m multiport --dports 1514,1515 \
  -m conntrack --ctstate NEW,ESTABLISHED,RELATED -m comment --comment "mgmt10-wazuh-agent" -j ACCEPT

if [ -n "$WAN_IP" ]; then
  iptables_add_once filter "$VLAN_CHAIN" -i "$MGMT_IF" -o "$DMZ_IF" -d "$WAZUH_IP" -p tcp --dport 443 \
    -m conntrack --ctstate NEW -m connmark --mark "$WAZUH_UI_MARK" \
    -m comment --comment "mgmt10-wazuh-ui-via-wan" -j ACCEPT
fi

if [ "$LOG_FORWARD_DROPS" = "1" ]; then
  ensure_chain filter QM_FWD_DROPLOG
  flush_chain filter QM_FWD_DROPLOG
  iptables_add_once filter QM_FWD_DROPLOG -m limit --limit 6/min --limit-burst 10 -j LOG --log-prefix "QM_FWD_DROP: " --log-level 4
  iptables_add_once filter QM_FWD_DROPLOG -j DROP
  iptables_add_once filter FORWARD -m conntrack --ctstate NEW -j QM_FWD_DROPLOG
fi

# IPv6 forward drop (extra safety)
if [ "$DISABLE_IPV6" = "1" ] && cmd_exists ip6tables; then
  ip6tables -P FORWARD DROP >/dev/null 2>&1 || true
fi

say "[+] Saving iptables..."
/etc/init.d/iptables save >/dev/null 2>&1 || true

say "[OK] setup-network done."
say "    - Add VLAN user:  qm-vlan add <VID> <GW/CIDR> (ex: qm-vlan add 100 172.16.100.1/24)"
say "    - Wazuh UI (inside VLAN): https://${WAN_IP:-<WAN_IP>}:${WAZUH_WAN_PORT}"
